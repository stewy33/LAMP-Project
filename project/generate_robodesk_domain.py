import copy
import sys
import opentamp.core.util_classes.common_constants as const
from opentamp.core.util_classes.robots import *


dom_str = """
# AUTOGENERATED. DO NOT EDIT.
# Configuration file for CAN domain. Blank lines and lines beginning with # are filtered out.

# implicity, all types require a name
Types: Robot, RobotPose, CollisionShape 

# Define the class location of each non-standard attribute type used in the above parameter type descriptions.

Attribute Import Paths: Vector1d opentamp.core.util_classes.matrix, Vector2d opentamp.core.util_classes.matrix, \
                        Vector3d opentamp.core.util_classes.matrix, ArmPose7d opentamp.core.util_classes.matrix, \
                        Table opentamp.core.util_classes.items, Box opentamp.core.util_classes.items, \
                        Basket opentamp.core.util_classes.items, Cloth opentamp.core.util_classes.items, \
                        Can opentamp.core.util_classes.items, Door opentamp.core.util_classes.items, \
                        Sphere opentamp.core.util_classes.items"""

robots = ["Baxter", "Sawyer", "Panda"]
for robot in robots:
    dom_str += ", {} opentamp.core.util_classes.robots".format(robot)

dom_str += """

Predicates Import Path: opentamp.core.util_classes.robot_predicates

"""


# Automated handling to setup robot types
r_types = ""
for r in robots:
    r_types += "{}, ".format(r)
r_types = r_types[:-2] + " - Robot"

rpose_types = ""
for r in robots:
    rpose_types += "{}Pose, ".format(r)
rpose_types = rpose_types[:-2] + " - RobotPose"

# Parameters can have multiple types through inheritance
subtypes = "\nSubtypes: Obstacle, Reachable - CollisionShape; \
                        Item, Target, SlideTarget, Handle, Button - Reachable; \
                        Cloth, Can, Box, Basket, Sphere - Item; \
                        Button - Can; \
                        Door - Obstacle; \
                        ClothTarget, BoxTarget, CanTarget, BasketTarget - Target"
subtypes += "; " + r_types + "; " + rpose_types + "\n"
dom_str += subtypes + "\n"


class PrimitivePredicates(object):
    def __init__(self):
        self.attr_dict = {}

    def add(self, name, attrs):
        self.attr_dict[name] = attrs

    def get_str(self):
        prim_str = "Primitive Predicates: "
        first = True
        for name, attrs in list(self.attr_dict.items()):
            for attr_name, attr_type in attrs:
                pred_str = attr_name + ", " + name + ", " + attr_type
                if first:
                    prim_str += pred_str
                    first = False
                else:
                    prim_str += "; " + pred_str
        return prim_str


pp = PrimitivePredicates()
pp.add("Reachable", [("value", "Vector3d"), ("rotation", "Vector3d")])
pp.add("CollisionShape", [("pose", "Vector3d"), ("rotation", "Vector3d")])
pp.add("Item", [("pose", "Vector3d"), ("rotation", "Vector3d")])
pp.add("Target", [("value", "Vector3d"), ("rotation", "Vector3d")])
pp.add("SlideTarget", [("value", "Vector3d"), ("rotation", "Vector3d")])

pp.add("Basket", [("geom", "Basket"), ("pose", "Vector3d"), ("rotation", "Vector3d")])
pp.add("Cloth", [("geom", "Cloth"), ("pose", "Vector3d"), ("rotation", "Vector3d")])
pp.add("Can", [("geom", "Can"), ("pose", "Vector3d"), ("rotation", "Vector3d")])
pp.add("Handle", [("geom", "Can"), ("pose", "Vector3d"), ("rotation", "Vector3d")])
pp.add("Sphere", [("geom", "Sphere"), ("pose", "Vector3d"), ("rotation", "Vector3d")])
pp.add("Box", [("geom", "Box"), ("pose", "Vector3d"), ("rotation", "Vector3d")])

pp.add(
    "BasketTarget",
    [("geom", "Basket"), ("value", "Vector3d"), ("rotation", "Vector3d")],
)
pp.add(
    "ClothTarget", [("value", "Vector3d"), ("rotation", "Vector3d"), ("geom", "Cloth")]
)
pp.add("CanTarget", [("value", "Vector3d"), ("rotation", "Vector3d"), ("geom", "Can")])
pp.add("BoxTarget", [("value", "Vector3d"), ("rotation", "Vector3d"), ("geom", "Box")])

pp.add("Robot", [("pose", "Vector3d"), ("rotation", "Vector3d")])
pp.add("RobotPose", [("value", "Vector3d"), ("rotation", "Vector3d")])

pp.add("Obstacle", [("geom", "Box"), ("pose", "Vector3d"), ("rotation", "Vector3d")])
pp.add(
    "Door",
    [
        ("geom", "Door"),
        ("pose", "Vector3d"),
        ("rotation", "Vector3d"),
        ("hinge", "Vector1d"),
    ],
)


for r in robots:
    try:
        r_geom = eval("{0}()".format(r))
    except:
        print("Could not load geom for {}".format(r))
        continue

    attrs = [("geom", r)]
    pose_attrs = []
    for arm in r_geom.arms:
        njnts = len(r_geom.jnt_names[arm])
        attrs.append((arm, "ArmPose{0}d".format(njnts)))
        pose_attrs.append((arm, "ArmPose{0}d".format(njnts)))
        gripper = r_geom.get_gripper(arm)
        njnts = r_geom.gripper_dim(arm)
        attrs.append((gripper, "Vector{}d".format(njnts)))
        pose_attrs.append((gripper, "Vector{}d".format(njnts)))
        attrs.append(("{}_ee_pos".format(arm), "Vector3d"))
        attrs.append(("{}_ee_rot".format(arm), "Vector3d"))
        pose_attrs.append(("{}_ee_pos".format(arm), "Vector3d"))
        pose_attrs.append(("{}_ee_rot".format(arm), "Vector3d"))

    pp.add(r, attrs)
    pp.add(r + "Pose", pose_attrs)

dom_str += pp.get_str() + "\n\n"


class DerivatedPredicates(object):
    def __init__(self):
        self.pred_dict = {}

    def add(self, name, args):
        self.pred_dict[name] = args

    def get_str(self):
        prim_str = "Derived Predicates: "
        first = True
        for name, args in list(self.pred_dict.items()):
            pred_str = name
            for arg in args:
                pred_str += ", " + arg

            if first:
                prim_str += pred_str
                first = False
            else:
                prim_str += "; " + pred_str

        return prim_str

    def copy(self):
        new_dp = DerivatedPredicates()
        new_dp.pred_dict = copy.copy(self.pred_dict)
        return new_dp


dp = DerivatedPredicates()
dp.add("At", ["Reachable", "Reachable"])
dp.add("AtRot", ["Reachable", "Reachable"])
dp.add("AtInit", ["Item", "Reachable"])
dp.add("Near", ["Reachable", "Reachable"])
dp.add("RobotAt", ["Robot", "RobotPose"])

dp.add("IsMP", ["Robot"])
dp.add("WithinJointLimit", ["Robot"])

dp.add("Stationary", ["Reachable"])
dp.add("Fixed", ["Reachable"])
dp.add("StationaryRot", ["Reachable"])
dp.add("StationaryNEq", ["Reachable", "Reachable"])
dp.add("StationaryBase", ["Robot"])
dp.add("StationaryArms", ["Robot"])
dp.add("StationaryLeftArm", ["Robot"])
dp.add("StationaryRightArm", ["Robot"])
dp.add("StationaryW", ["Obstacle"])
dp.add("StationaryWNEq", ["Obstacle", "Obstacle"])
dp.add("StationaryWBase", ["Obstacle"])
dp.add("StationaryXY", ["Reachable"])
dp.add("StationaryYZ", ["Reachable"])
dp.add("StationaryXZ", ["Reachable"])

dp.add("CloseGripper", ["Robot"])
dp.add("CloseGripperLeft", ["Robot"])
dp.add("CloseGripperRight", ["Robot"])
dp.add("OpenGripper", ["Robot"])
dp.add("OpenGripperLeft", ["Robot"])
dp.add("OpenGripperRight", ["Robot"])

dp.add("Obstructs", ["Robot", "CollisionShape"])
dp.add("ObstructsHolding", ["Robot", "CollisionShape", "CollisionShape"])
dp.add("Collides", ["CollisionShape", "CollisionShape"])
dp.add("RCollides", ["Robot", "CollisionShape"])
dp.add("RSelfCollides", ["Robot"])

dp.add("EEReachable", ["Robot", "Reachable"])
dp.add("EEReachableLeft", ["Robot", "Reachable"])
dp.add("EEReachableRight", ["Robot", "Reachable"])
dp.add("EEApproachLeft", ["Robot", "Reachable"])
dp.add("EEApproachRight", ["Robot", "Reachable"])
dp.add("EEApproachAbsLeft", ["Robot", "Reachable"])
dp.add("EEApproachAbsRight", ["Robot", "Reachable"])
dp.add("EEApproachStackLeft", ["Robot", "Reachable", "Reachable"])
dp.add("EEApproachStackRight", ["Robot", "Reachable", "Reachable"])
dp.add("EERetreatLeft", ["Robot", "Reachable"])
dp.add("EERetreatRight", ["Robot", "Reachable"])
dp.add("EEWeakRetreatRight", ["Robot", "Reachable"])
dp.add("EERetreatAbsLeft", ["Robot", "Reachable"])
dp.add("EERetreatAbsRight", ["Robot", "Reachable"])
dp.add("EERetreatStackLeft", ["Robot", "Reachable", "Reachable"])
dp.add("EERetreatStackRight", ["Robot", "Reachable", "Reachable"])
dp.add("EEAtXYLeft", ["Robot", "Reachable"])
dp.add("EEAtXYRight", ["Robot", "Reachable"])
dp.add("EEAtXZLeft", ["Robot", "Reachable"])
dp.add("EEAtXZRight", ["Robot", "Reachable"])
dp.add("EEAtYZLeft", ["Robot", "Reachable"])
dp.add("EEAtYZRight", ["Robot", "Reachable"])
dp.add("EEAtRelXYLeft", ["Robot", "Reachable"])
dp.add("EEAtRelXYRight", ["Robot", "Reachable"])
dp.add("EEAtXRelLeft", ["Robot", "Reachable"])
dp.add("EEAtXRelRight", ["Robot", "Reachable"])
dp.add("EEAtYRelLeft", ["Robot", "Reachable"])
dp.add("EEAtYRelRight", ["Robot", "Reachable"])
dp.add("EEAtZRelLeft", ["Robot", "Reachable"])
dp.add("EEAtZRelRight", ["Robot", "Reachable"])
dp.add("EEAtRelXZLeft", ["Robot", "Reachable"])
dp.add("EEAtRelXZRight", ["Robot", "Reachable"])
dp.add("EEAtRelYZLeft", ["Robot", "Reachable"])
dp.add("EEAtRelYZRight", ["Robot", "Reachable"])
dp.add("Approach", ["Robot", "Reachable"])
dp.add("ApproachLeft", ["Robot", "Reachable"])
dp.add("ApproachRight", ["Robot", "Reachable"])
dp.add("NearApproach", ["Robot", "Reachable"])
dp.add("NearApproachLeft", ["Robot", "Reachable"])
dp.add("NearApproachRight", ["Robot", "Reachable"])
dp.add("NearRetreatRight", ["Robot", "Reachable"])

dp.add("EEReachableRot", ["Robot", "Reachable"])
dp.add("EEReachableLeftRot", ["Robot", "Reachable"])
dp.add("EEReachableRightRot", ["Robot", "Reachable"])
dp.add("ApproachRot", ["Robot", "Reachable"])
dp.add("ApproachLeftRot", ["Robot", "Reachable"])
dp.add("ApproachRightRot", ["Robot", "Reachable"])
dp.add("EEAtLeftRot", ["Robot", "Reachable"])
dp.add("EEAtRightRot", ["Robot", "Reachable"])
dp.add("NearApproachRot", ["Robot", "Reachable"])
dp.add("NearApproachLeftRot", ["Robot", "Reachable"])
dp.add("NearApproachRightRot", ["Robot", "Reachable"])

dp.add("InGripperLeft", ["Robot", "Reachable"])
dp.add("InGripperRight", ["Robot", "Reachable"])
dp.add("InGripper", ["Robot", "Reachable"])
dp.add("NearGripper", ["Robot", "Reachable"])
dp.add("NearGripperLeft", ["Robot", "Reachable"])
dp.add("NearGripperRight", ["Robot", "Reachable"])
dp.add("GripperAtLeft", ["Robot", "Reachable"])
dp.add("GripperAtRight", ["Robot", "Reachable"])
dp.add("GripperAt", ["Robot", "Reachable"])

dp.add("GrippersDownRot", ["Robot"])
dp.add("LeftGripperDownRot", ["Robot"])
dp.add("RightGripperDownRot", ["Robot"])

# Useful for Robosuite
dp.add("HeightBlock", ["Item", "Item"])
dp.add("AboveTable", ["Item"])

# Useful for Robodesk
# Door isn't in every domain, and FF doesn't like unused types
dp.add("Lifted", ["Item", "Robot"])
dp.add("InReach", ["Reachable", "Robot"])
dp.add("Stacked", ["Item", "Item"])
dp.add("Stackable", ["Item", "Item"])
door_dp = dp.copy()
door_dp.add("DeskHeightBlock", ["Item", "Item"])
door_dp.add("SlideDoorAt", ["Reachable", "Door"])
door_dp.add("SlideDoorOpen", ["Reachable", "Door"])
door_dp.add("SlideDoorClose", ["Reachable", "Door"])
door_dp.add("SlideDoorAtOpen", ["Reachable", "Door"])
door_dp.add("SlideDoorAtClose", ["Reachable", "Door"])
door_dp.add("InSlideDoor", ["Item", "Door"])
door_dp.add("EEApproachInDoorLeft", ["Robot", "Door"])
door_dp.add("EERetreatInDoorLeft", ["Robot", "Door"])
door_dp.add("EEApproachInDoorRight", ["Robot", "Door"])
door_dp.add("EERetreatInDoorRight", ["Robot", "Door"])
door_dp.add("NearApproachInDoorLeft", ["Robot", "Door"])
door_dp.add("NearApproachInDoorRight", ["Robot", "Door"])


header_str = """

# The first set of parentheses after the colon contains the
# parameters. The second contains preconditions and the third contains
# effects. This split between preconditions and effects is only used
# for task planning purposes. Our system treats all predicates
# similarly, using the numbers at the end, which specify active
# timesteps during which each predicate must hold

"""

base_dom_str = dom_str
dom_str += dp.get_str() + "\n" + header_str
door_dom_str = base_dom_str + door_dp.get_str() + "\n" + header_str


class Action(object):
    def __init__(self, name, timesteps, pre=None, post=None):
        self.name = name
        self.timesteps = timesteps
        if pre is not None:
            self.pre = pre

        if post is not None:
            self.post = post

    def to_str(self):
        time_str = ""
        cond_str = "(and "
        for pre, timesteps in self.pre:
            cond_str += pre + " "
            time_str += timesteps + " "

        cond_str += ")"
        cond_str += "(and "
        for eff, timesteps in self.eff:
            cond_str += eff + " "
            time_str += timesteps + " "

        cond_str += ")"
        return (
            "Action "
            + self.name
            + " "
            + str(self.timesteps)
            + ": "
            + self.args
            + " "
            + cond_str
            + " "
            + time_str
        )


class Move(Action):
    def __init__(self):
        self.name = "moveto"
        self.timesteps = 19  # 17
        end = self.timesteps - 1
        self.end = end
        self.args = "(?robot - Robot ?start - RobotPose ?end - RobotPose)"
        self.pre = [  # ('(RobotAt ?robot ?start)', '{}:{}'.format(0, -1)),
            # ('(not (RobotAt ?robot ?end))', '{}:{}'.format(0, -1)),
            (
                "(forall (?obj - Item)\
                        (not (Obstructs ?robot ?obj)))",
                "{}:{}".format(1, end - 1),
            ),
            (
                "(forall (?obj - Item)\
                        (Stationary ?obj))",
                "{}:{}".format(0, end - 1),
            ),
            (
                "(forall (?obs - Obstacle) (StationaryW ?obs))",
                "{}:{}".format(0, end - 1),
            ),
            ("(IsMP ?robot)", "{}:{}".format(0, end - 1)),
            ("(WithinJointLimit ?robot)", "{}:{}".format(0, end)),
            (
                "(forall (?w - Obstacle) (not (RCollides ?robot ?w)))",
                "{}:{}".format(1, end - 1),
            ),
            # ('(forall (?w - Obstacle) (not (RCollides ?robot ?w)))', '{}:{}'.format(0, 0)),
            # ('(forall (?obj - Item) (not (Obstructs ?robot ?obj)))', '0:0'),
            # ('(not (RSelfCollides ?robot))', '0:{}'.format(end)),
        ]

        self.eff = [
            (" (not (RobotAt ?robot ?start))", "{}:{}".format(end, end - 1)),
            ("(RobotAt ?robot ?end)", "{}:{}".format(end, end - 1)),
        ]


def write_domain(actions, fname):
    dom_str = door_dom_str
    for action in actions:
        dom_str += "\n\n"
        print(action.name)
        dom_str += action.to_str()
    dom_str = dom_str.replace("            ", "")
    dom_str = dom_str.replace("    ", "")
    dom_str = dom_str.replace("    ", "")
    print(dom_str)
    with open(fname, "w") as f:
        f.write(dom_str)


write_domain([Move()], "project/move_to_grasp.domain")
